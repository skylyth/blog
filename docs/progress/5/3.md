# 面试题之如何实现一个深拷贝

## 引言

上篇文章详细介绍了浅拷贝 Object.assign，并对其进行了模拟实现，在实现的过程中，介绍了很多基础知识。今天这篇文章我们来看看一道必会面试题，即如何实现一个深拷贝。本文会详细介绍对象、数组、循环引用、引用丢失、Symbol 和递归爆栈等情况下的深拷贝实践，欢迎阅读。

## 第一步：简单实现

其实深拷贝可以拆分成 2 步，浅拷贝 + 递归，浅拷贝时判断属性值是否是对象，如果是对象就进行递归操作，两个一结合就实现了深拷贝。

根据上篇文章内容，我们可以写出简单浅拷贝代码如下。

<<< @/markdown/progress/5-3/1.js

上面代码是浅拷贝实现，只要稍微改动下，加上是否是对象的判断并在相应的位置使用递归就可以实现简单深拷贝。

<<< @/markdown/progress/5-3/2.js

一个简单的深拷贝就完成了，但是这个实现还存在很多问题。

- 1、没有对传入参数进行校验，传入 null 时应该返回 null 而不是 {}

- 2、对于对象的判断逻辑不严谨，因为 typeof null === 'object'

- 3、没有考虑数组的兼容

## 第二步：拷贝数组

我们来看下对于对象的判断，之前在【进阶3-3期】有过介绍，判断方案如下。

<<< @/markdown/progress/5-3/3.js

但是用在这里并不合适，因为我们要保留数组这种情况，所以这里使用 typeof 来处理。

<<< @/markdown/progress/5-3/4.js

改动过后的 isObject 判断逻辑如下。

<<< @/markdown/progress/5-3/5.js

所以兼容数组的写法如下。

<<< @/markdown/progress/5-3/6.js

## 第三步：循环引用

我们知道 JSON 无法深拷贝循环引用，遇到这种情况会抛出异常。

<<< @/markdown/progress/5-3/7.js

### 1、使用哈希表
解决方案很简单，其实就是循环检测，我们设置一个数组或者哈希表存储已拷贝过的对象，当检测到当前对象已存在于哈希表中时，取出该值并返回即可。

<<< @/markdown/progress/5-3/8.js

测试一下，看看效果如何。

<<< @/markdown/progress/5-3/9.js

完美！

### 2、使用数组
这里使用了ES6 中的 WeakMap 来处理，那在 ES5 下应该如何处理呢？

也很简单，使用数组来处理就好啦，代码如下。

<<< @/markdown/progress/5-3/10.js

现在已经很完美的解决了循环引用这种情况，那其实还是一种情况是引用丢失，我们看下面的例子。

<<< @/markdown/progress/5-3/11.js

引用丢失在某些情况下是有问题的，比如上面的对象 obj2，obj2 的键值 a 和 b 同时引用了同一个对象 obj1，使用 cloneDeep2 进行深拷贝后就丢失了引用关系变成了两个不同的对象，那如何处理呢。

其实你有没有发现，我们的 cloneDeep3 已经解决了这个问题，因为只要存储已拷贝过的对象就可以了。

<<< @/markdown/progress/5-3/12.js

完美！

## 第四步：拷贝 Symbol

这个时候可能要搞事情了，那我们能不能拷贝 Symol 类型呢？

当然可以，不过 Symbol 在 ES6 下才有，我们需要一些方法来检测出 Symble 类型。

方法一：Object.getOwnPropertySymbols(...)

方法二：Reflect.ownKeys(...)

对于方法一可以查找一个给定对象的符号属性时返回一个 ?symbol 类型的数组。注意，每个初始化的对象都是没有自己的 symbol 属性的，因此这个数组可能为空，除非你已经在对象上设置了 symbol 属性。（来自MDN）

<<< @/markdown/progress/5-3/13.js

对于方法二返回一个由目标对象自身的属性键组成的数组。它的返回值等同于Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))。(来自MDN)

<<< @/markdown/progress/5-3/14.js

### 方法一

思路就是先查找有没有 Symbol 属性，如果查找到则先遍历处理 Symbol 情况，然后再处理正常情况，多出来的逻辑就是下面的新增代码。

<<< @/markdown/progress/5-3/15.js

测试下效果

<<< @/markdown/progress/5-3/16.js

完美！

### 方法二

<<< @/markdown/progress/5-3/17.js

这里使用了 Reflect.ownKeys() 获取所有的键值，同时包括 Symbol，对 source 遍历赋值即可。

写到这里已经差不多了，我们再延伸下，对于 target 换一种写法，改动如下。

<<< @/markdown/progress/5-3/18.js

在改动 1 中，返回一个新数组或者新对象，获取到源对象之后就可以如改动 2 所示传入 target 遍历赋值即可。

Reflect.ownKeys() 这种方式的问题在于不能深拷贝原型链上的数据，因为返回的是目标对象自身的属性键组成的数组。如果想深拷贝原型链上的数据怎么办，那用 for..in 就可以了。

我们再介绍下两个知识点，分别是构造字面量数组时使用展开语法和构造字面量对象时使用展开语法。（以下代码示例来源于 MDN）

### 1、展开语法之字面量数组
这是 ES2015 （ES6） 才有的语法，可以通过字面量方式, 构造新数组，而不再需要组合使用 push, splice, concat 等方法。

<<< @/markdown/progress/5-3/19.js

这里的使用方法和参数列表的展开有点类似。

<<< @/markdown/progress/5-3/20.js

返回的是新数组，对新数组修改之后不会影响到旧数组，类似于 arr.slice()。

<<< @/markdown/progress/5-3/21.js

展开语法和 Object.assign() 行为一致, 执行的都是浅拷贝（即只遍历一层）。

<<< @/markdown/progress/5-3/22.js

这里 a 是多层数组，b 只拷贝了第一层，对于第二层依旧和 a 持有同一个地址，所以对 b 的修改会影响到 a。

### 2、展开语法之字面量对象
这是 ES2018 才有的语法，将已有对象的所有可枚举属性拷贝到新构造的对象中，类似于 Object.assign() 方法。

<<< @/markdown/progress/5-3/23.js

Object.assign() 函数会触发 setters，而展开语法不会。有时候不能替换或者模拟 Object.assign() 函数，因为会得到意想不到的结果，如下所示。

<<< @/markdown/progress/5-3/24.js

这里实际上是将多个解构变为剩余参数（ rest ），然后再将剩余参数展开为字面量对象.

## 第五步：破解递归爆栈

上面四步使用的都是递归方法，但是有一个问题在于会爆栈，错误提示如下。

<<< @/markdown/progress/5-3/25.js

那应该如何解决呢？其实我们使用循环就可以了，代码如下。

<<< @/markdown/progress/5-3/26.js

## 参考

- [深入剖析 JavaScript 的深复制](https://jerryzou.com/posts/dive-into-deep-clone-in-javascript/)
- [深拷贝的终极探索（99%的人都不知道）](https://segmentfault.com/a/1190000016672263)
- [深入 js 深拷贝对象](https://www.jianshu.com/p/b08bc61714c7)
- [MDN 之展开语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax)
- [MDN 之 Symbol](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)