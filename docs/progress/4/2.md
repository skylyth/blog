# JavaScript深入之重新认识箭头函数的this

我们知道this绑定规则一共有5种情况：

- 1、默认绑定（严格/非严格模式）
- 2、隐式绑定
- 3、显式绑定
- 4、new绑定
- 5、箭头函数绑定

其实大部分情况下可以用一句话来概括，**this总是指向调用该函数的对象**。

但是对于箭头函数并不是这样，是根据外层（函数或者全局）作用域（**词法作用域**）来决定this。

对于箭头函数的this总结如下：

1. 箭头函数不绑定this，箭头函数中的this相当于普通变量。

2. 箭头函数的this寻值行为与普通变量相同，在作用域中逐级寻找。

3. 箭头函数的this无法通过bind，call，apply来直接修改（可以间接修改）。

4. 改变作用域中this的指向可以改变箭头函数的this。

5. eg. function closure(){()=>{//code }}，在此例中，我们通过改变封包环境closure.bind(another)()，来改变箭头函数this的指向。

## 题目1

<<< @/markdown/progress/4-2/1.js


***
***

空

白

占

位

符

***
***

正确答案如下：

<<< @/markdown/progress/4-2/2.js

最后一个person1.show4.call(person2)()有点复杂，我们来一层一层的剥开。

- 1、首先是var func1 = person1.show4.call(person2)，这是显式绑定，调用者是person2，show4函数指向的是person2。

- 2、然后是func1()，箭头函数绑定，this指向外层作用域，即person2函数作用域

首先要说明的是，箭头函数绑定中，this指向外层作用域，并不一定是第一层，也不一定是第二层。

因为没有自身的this，所以只能根据作用域链往上层查找，直到找到一个绑定了this的函数作用域，并指向调用该普通函数的对象。

## 题目2

<<< @/markdown/progress/4-2/3.js

***
***

空

白

占

位

符

***
---


正确答案如下：

<<< @/markdown/progress/4-2/4.js

题目一和题目二的区别在于题目二使用了new操作符。

使用 new 操作符调用构造函数，实际上会经历一下4个步骤：
- 创建一个新对象；
- 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；
- 执行构造函数中的代码（为这个新对象添加属性）；
- 返回新对象。

## 参考

- [从这两套题，重新认识JS的this、作用域、闭包、对象](https://juejin.im/post/59aa71d56fb9a0248d24fae3)