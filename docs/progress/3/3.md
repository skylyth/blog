# 闭包面试题解

作用域指的是一个变量和函数的作用范围，JS中**函数内声明的所有变量在函数体内始终是可见的**，在ES6前有全局作用域和局部作用域，但是没有块级作用域（catch只在其内部生效），局部变量的优先级高于全局变量。

## 作用域

### 变量提升

<<< @/markdown/progress/3-3/1.js

上面的代码输出是undefined，这是因为局部变量scope变量提升了，等效于下面

<<< @/markdown/progress/3-3/2.js

:::tip
如果在局部作用域中忘记var，那么变量就被声明为全局变量。
:::

## 作用域链

每个函数都有自己的执行上下文环境，当代码在这个环境中执行时，会创建变量对象的作用域链，作用域链是一个对象列表或对象链，它保证了变量对象的有序访问。

作用域链的开始是当前代码执行环境的变量对象，常被称之为“活跃对象”（AO），变量的查找会从第一个链的对象开始，如果对象中包含变量属性，那么就停止查找，如果没有就会继续向上级作用域链查找，直到找到全局对象中

## 闭包

<<< @/markdown/progress/3-3/3.js

上面在函数中返回了两个闭包，这两个闭包都维持着对外部作用域的引用。闭包中会将外部函数的自由对象添加到自己的作用域链中，所以可以通过内部函数访问外部函数的属性，这也是javascript模拟私有变量的一种方式。

## 闭包面试题解

由于作用域链机制的影响，闭包只能取得内部函数的最后一个值，这引起的一个副作用就是如果内部函数在一个循环中，那么变量的值始终为最后一个值。

这个代码再贴一遍

<<< @/markdown/progress/3-3/4.js

如果要强制返回预期的结果，怎么办？？？

### 方法1：立即执行函数

<<< @/markdown/progress/3-3/5.js

### 方法2：返回一个匿名函数赋值

<<< @/markdown/progress/3-3/6.js

无论是立即执行函数还是返回一个匿名函数赋值，原理上都是因为变量的按值传递，所以会将变量i的值复制给实参num，在匿名函数的内部又创建了一个用于访问num的匿名函数，这样每个函数都有了一个num的副本，互不影响了。

### 方法3：使用ES6中的let

<<< @/markdown/progress/3-3/7.js

解释下原理：

<<< @/markdown/progress/3-3/8.js

循环时，let声明i,所以整个块是块级作用域，那么data[0]这个函数就成了一个闭包。这里用｛｝表达并不符合语法，只是希望通过它来说明let存在时，这个for循环块是块级作用域，而不是全局作用域。

上面的块级作用域，就像函数作用域一样，函数执行完毕，其中的变量会被销毁，但是因为这个代码块中存在一个闭包，闭包的作用域链中引用着块级作用域，所以在闭包被调用之前，这个块级作用域内部的变量不会被销毁。

<<< @/markdown/progress/3-3/9.js

当执行data[1]()时，进入下面的执行环境。

<<< @/markdown/progress/3-3/10.js

在上面这个执行环境中，它会首先寻找该执行环境中是否存在i，没有找到，就沿着作用域链继续向上到了其所在的块作用域执行环境，找到了i = 1,于是输出了1。

## 参考

- [深入javascript——作用域和闭包](https://segmentfault.com/a/1190000000618597)
- [ES6之let（理解闭包）和const命令](https://www.cnblogs.com/zhuzhenwei918/p/6131345.html)